<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="theme-color" content="#000000">
  <!--
      manifest.json provides metadata used when your web app is added to the
      homescreen on Android. See https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
    -->
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
  <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
  <link href="https://fonts.googleapis.com/css?family=Slabo+13px" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Poppins:400,700|Roboto+Slab:400,700&amp;subset=latin-ext" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css">
  <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
  <title>Mike Cassidy</title>
</head>
<style>
  /*  
        This is to make sure
        the canvas is in the right position
        on all browsers    
    */

  /* canvas {
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
  }

  #root {
    z-index: 1;
  } */
</style>

<body>
  <noscript>
    You need to enable JavaScript to run this app.
  </noscript>

  <div id="root"></div>
  <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  <!-- <canvas></canvas>
  <script>

    var canvas = document.querySelector("canvas");
    var width = window.innerWidth;
    var height = window.innerHeight;
    var context = canvas.getContext("2d");
    canvas.setAttribute("width", width);
    canvas.setAttribute("height", height);


    var fov = 200;

    var point = [];
    var points = [];
    var point3d = [];

    var HALF_WIDTH = width / 2;
    var HALF_HEIGHT = height / 2;

    var numPoints = 1000;
    var x3d = 0;
    var y3d = 0;
    var z3d = 0;

    for (var i = 0; i < numPoints; i++) {
      point = [(Math.random() * width / 2) - width / 4, (Math.random() * height / 2) - height / 4, (Math.random() * width / 2) - width / 4];
      points.push(point);
    }

    function draw() {

      // This just clears the screen    
      context.fillStyle = "rgb(0,0,0)";
      context.fillRect(0, 0, width, height);

      // This loop takes a bunch of 3D vertices and draws them using a 2D perspective projection
      for (var i = 0; i < numPoints; i++) {
        // Get a vertex
        point3d = points[i];

        // // Get the z coordinate - this is the depth
        z3d = point3d[2];

        // substract a value - this will move it along the z axis.
        z3d -= 0.4;

        // if the z coordinate for this vertex is less than the Fielf of View (FOV),
        // Add half the width to move it back. This makes an endless starfield.
        // feel free to disable this if you want...
        if (z3d < -fov) z3d += HALF_WIDTH;

        // replace the original z position with this new z position.    
        point3d[2] = z3d;

        // Now get all the vertices        
        x3d = point3d[0];
        y3d = point3d[1];
        z3d = point3d[2];

        // Decide on the size of the point by taking the FOV and dividing it by the FOV + the z pos
        var scale = fov / (fov + z3d);

        //scale = 1.0;
        // Now create the 2D perspective projection.
        // create a 2D x and y position by multiplying the x and y coordinates by the scale
        // Add half the width and height to translate the coordinates to the origin.
        var x2d = (x3d * scale) + HALF_WIDTH;
        var y2d = (y3d * scale) + HALF_HEIGHT;

        // Draw a square of size 'scale', in position x2d, y2d.
        // This code is more complex than you might be used to because it's pure JS.
        context.lineWisdth = scale;
        context.strokeStyle = "rgb(255,255,255)";
        context.beginPath();
        context.moveTo(x2d, y2d);
        context.lineTo(x2d + scale, y2d);
        context.stroke();

        //That really is it...

      }

    }

    setInterval(draw, 50);









  </script> -->
</body>

</html>